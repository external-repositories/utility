#ifndef UTILITY_H
#define UTILITY_H

#include <string>
#include <vector>
#include <memory>

#include "easylogging++.h"

/**
 * @brief
 * A collection of common operations originally developed for use in Nuclear Data
 * projects at Los Alamos National Laboratory.  
 */
namespace utility{

/* functions */
/** @returns A copy of the argument value */
template< typename T >
T copy( const T& t ){ return t; }

/* forward declaration of function signatures */
std::string 
extractCommand( const std::string& card );

template< typename Iterator >
void 
echoErroneousLine( Iterator lineBegin, Iterator positionIterator,
                   const Iterator& end, long lineNumber );

template< typename Iterator >
Iterator
findLineBegin( Iterator positionIterator );

bool 
verifyString( const std::string& card, 
              const int length );

std::string
slurpFileToMemory( const std::string& filename );

/* forward declaration of classes */
template< typename Base, template< typename > class... Decorators >
struct DecoratedTypeName;

template < typename T >
class ID;

template< typename Left, typename Right, bool condition >
struct TypeSwitch;

template < typename data >
class View;

/**
 * @brief
 * A template to remove const-ness and reference-ness from consideration of a 
 * parameter type @tparam T
 */
template< typename T >
using clean =
  typename std::remove_const
  < typename std::remove_reference< T >::type >::type;

/**
 * @brief
 * A struct template providing a boolean static member variable, value, defining
 * whether a parameter type @tparam T is a container type
 */
template< typename T, typename _ = void >
struct IsContainer : std::false_type {};

template< typename T >
struct IsContainer
< T, std::conditional_t< false,
                         typename T::iterator, void > > : std::true_type {};

/**
 * @brief
 * A struct template providing a boolean static member variable, value, defining
 * whether a parameter type @tparam T is an instantiation of the std::shared_ptr
 * template
 */
template< typename T, typename _ = void >
struct IsSharedPtr : std::false_type {};

template< typename T >
struct IsSharedPtr< T, std::conditional_t< false,
                                           typename T::element_type, void > > :
    std::conditional_t< std::is_same< T, typename std::shared_ptr
                                         < typename T::element_type > >::value,
                        std::true_type, std::false_type > {};

/**
 * @brief
 * A struct template providing a boolean static member variable, value, defining
 * whether a parameter type @tparam T is an instantiation of the std::unique_ptr
 * template
 */
template< typename T, typename _ = void >
struct IsUniquePtr : std::false_type {};

template< typename T >
struct IsUniquePtr< T, std::conditional_t< false,
                                           typename T::element_type, void > > :
    std::conditional_t< std::is_same< T, typename std::unique_ptr
                                         < typename T::element_type > >::value,
                        std::true_type, std::false_type > {};
/**
 * @brief
 * A struct template providing a boolean static member variable, value, defining
 * whether a parameter type @tparam T is an instantiation of the std::unique_ptr
 * template or std::shared_ptr
 */

template< typename T >
struct IsSmartPtr : std::conditional_t
                    < IsUniquePtr< T >::value || IsSharedPtr< T >::value,
                      std::true_type, std::false_type > {};

/**
 * @brief
 * A struct template providing a boolean static member variable, value, defining
 * whether a parameter type @tparam T is an iterator type
 */
template< typename T, typename _ = void >
struct IsIterator : std::false_type {};

template< typename T >
struct IsIterator
< T, std::conditional_t< false,
                         typename std::iterator_traits< T >::iterator_category,
                         void > > : std::true_type {};

/* faux forward declaration of nested namespaces */
namespace realNumberStringCollection{}
namespace string{}
namespace stream{}
}

#include "utility/DecoratedTypeName.hpp"
#include "utility/ID.hpp"
#include "utility/TypeSwitch.hpp"
#include "utility/View.hpp"
#include "utility/echoErroneousLine.hpp"
#include "utility/findLineBegin.hpp"

#endif
