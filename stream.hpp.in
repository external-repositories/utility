#ifndef UTILITY_STREAM_H
#define UTILITY_STREAM_H

#include <istream>
#include <map>

#include "utility.hpp"

namespace utility{

/**
 * @brief
 * A collection of functions to extract and verify values from input streams.
 */
namespace stream{

/* Forward Declaration of function signatures (ordered alphabetically) */
/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * trimmed string is either '1' or '0'. Permits EOF without throwing an exception.
 */
bool 
getBool( std::istream& is, 
         const std::string& name,
         bool& found );

/**
* @brief 
* Extracts the next white space delimited string from a stream and verifies the 
* trimmed string is either '1' or '0'.
*/
bool 
getBool( std::istream& is, 
         const std::string& name );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string represent a valid energy value (in eV). Permits EOF without throwing an
 * exception.  
 */
double 
getEnergy( std:: istream& is, 
           bool& found,
           const std::string& name );

/** 
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string represent a valid energy value (in eV)
 */
double 
getEnergy( std:: istream& is,
           const std::string& name );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the 
 * string describes an integer. Permits EOF without throwing an exception.
 */
int
getInteger( std::istream& is, 
            const std::string& name, 
            bool& found );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string corresponds to an integer.
 */
int 
getInteger( std::istream& is, 
            const std::string& name );

/**
 * @brief
 * Extracts the next white space delimited string from a stream and verifies
 * the string corresponds to an integer between lBound (inclusive) and rBound 
 * (exclusive) argument values. Permits EOF without throwing an exception.
 */
int 
getIntInRange(std::istream& is, 
              const std::string& name, 
              const int lBound,
              const int rBound,
              bool& found );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies
 * the string corresponds to an integer between lBound (inclusive) and rBound 
 * (exclusive) argument values. 
 */
int 
getIntInRange(std::istream& is, 
              const std::string& name, 
              const int lBound,
              const int rBound );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the 
 * string corresponds to an integer greater than the *bound* argument. Permits 
 * EOF without throwing an exception.
 */
int 
getIntWithLBound( std::istream& is, 
                  const std::string& name, 
                  const int bound, 
                  bool& found );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string corresponds to an integer greater than the *bound* argument. 
 */
int 
getIntWithLBound( std::istream& is, 
                  const std::string& name, 
                  const int bound );

/**
 * @brief
 * Extracts the next newline character delimited string from a stream. 
 */
std::string 
getLine( std::istream& is );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string corresponds to a real number format recognized in the Fortran language. 
 * Permits EOF without throwing an exception.
 */
double 
getRealNumber( std::istream& is, 
               const std::string& name, 
               bool& found );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string correspond to a real number format recognized in the Fortran language. 
 */
double 
getRealNumber( std::istream& is, 
               const std::string& name );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies
 * the string corresponds to a real number greater than or equal to the *bound* 
 * argument. Permits EOF without throwing an exception.
 */
double
getRealWithLBound( std::istream& is, 
                   const std::string& name, 
                   const double bound, 
                   bool& found );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies
 * the string corresponds to an real number greater than or equal to the *bound* 
 * argument. 
 */
double
getRealWithLBound( std::istream& is, 
                   const std::string& name, 
                   const double bound );
/**
 * @brief 
 * Extracts the next quote delimited string from a stream and verifies the length
 * is less than or equal to the *length* argument. Allow EOF without throwing. 
 */
std::string 
getStringArg( std::istream& is, 
              const std::string& name, 
              const int length );

/**
 * @brief 
 * Extracts the next quote delimited string from a stream and verifies the length
 * is less than or equal to the *length* argument. 
 */
std::string 
getStringArg( std::istream& is, 
              const std::string& name, 
              const int length,
              bool& found );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string represent a valid temperature value (in Kelvin). Permits EOF without 
 * throwing an exception.  
 */
double 
getTemperature( std::istream& is, 
                bool& found,
                const std::string& name = std::string("tempd") );

/**
 * @brief 
 * Extracts the next white space delimited string from a stream and verifies the
 * string represent a valid temperature value (in Kelvin)
 */
double 
getTemperature( std::istream& is,
		      const std::string& name = std::string("tempd") );

/**
 * @brief 
 * Read a specified number of characters from the stream
 */
std::string 
readString( std::istream& is, 
            const std::string::size_type count );

/**
 * @brief 
 * Reads a specified number of characters from the stream or until the
 * delimeter is found.
 */
std::string 
readString( std::istream& is, 
            const std::string::size_type count,
            const char delim );

  /** @{
   *  @name Linked x,y template streaming functions
   */
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Linked x,y template streaming functions
  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  /** @brief Read a value from a stream
   *
   *  The readValue function will read a value of type Y from a stream and
   *  transform it into its corresponding X value. Only those x values that are
   *  referenced in the map are considered as legal x values.
   *
   *  Simply put, the readValue function will read a value of type Y from a
   *  stream and transform it into its corresponding X value. This function can
   *  for instance be used in the implementation of iostream operators of
   *  enumerators for which the values are linked to other types such as
   *  strings, integers or even doubles. This function is defined as a template
   *  function so that the same code does not have to be written multiple
   *  times.
   *
   *  @todo investigate the use of a template linker class instead of the map
   *        to extend the x,y linking beyond one on one values (e.g. linked a
   *        range of y values to a given x value, etc.).
   *
   *  @param[in,out] in   the input stream from which to read
   *  @param[in,out] x    the x value
   *  @param[in] values   the map linking y to x values
   *
   *  @return The input stream. If the function failed to read one of the values
   *          from the map, the position in the stream will be unchanged and
   *          std::ios_base::failbit will be set. In this case the value of x
   *          will also be unchanged.
   */
  template <typename X, typename Y> std::istream& readValue(std::istream& in,
          X& x, const std::map<Y, X>& values) noexcept;

  /** @brief Write a value to a stream
   *
   *  The writeValue function writes the corresponding Y value to a stream
   *  instead of the given X value. Only those x values that are referenced in
   *  the map are considered as legal x values. Nothing will be written to the
   *  stream if the x value is not referenced in the map.
   *
   *  Simply put, the writeValue function does the same thing by writing the
   *  corresponding Y value of a given X value to a stream. This function can
   *  for instance be used in the implementation of iostream operators of
   *  enumerators for which the values are linked to other types such as
   *  strings, integers or even doubles. This function is defined as a template
   *  function so that the same code does not have to be written multiple
   *  times.
   *
   *  @param[in,out] out   the output stream to which has to be written
   *  @param[in] x         the x value
   *  @param[in] values    the map linking x to y values
   *
   *  @return The modified output stream
   */
  template <typename X, typename Y> std::ostream& writeValue(std::ostream& out,
          const X& x, const std::map<X, Y>& values) noexcept;
  /** @}
   */
} // namespace stream
} // namespace utility

// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Template function implementation include files
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#include "utility/stream/src/xystream.hpp"

#endif
